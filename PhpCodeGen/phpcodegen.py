import re, sublime, sublime_plugin, json

class PhpCodeGenCommand(sublime_plugin.TextCommand):

    settings = {

        "docblockTagGroup": {},

        "debugMode": False,
        "autoGenerateDockBlocks": True,

        "numberOfSpaces": 1,

        "newLinesAfterClassDeclaration": 1,
        "newLinesBeforeClassClosingBrace": 1,
        "newLinesAfterMethodDeclaration": 1,
        "newLinesBeforeMethodClosingBrace": 1,
        
        "newLinesAboveClassDocBlock": 1,
        "newLinesBelowClassDocBlock": 1,
        "newLinesAboveConstantDockBlock": 1,
        "newLinesBelowConstantDockBlock": 0,
        "newLinesAbovePropertyDockBlock": 1,
        "newLinesBelowPropertyDockBlock": 0,
        "newLinesAboveMethodDockBlock": 1,
        "newLinesBelowMethodDockBlock": 0,

        "defaultMethodVisibility": "public",
        "defaultPropertyVisibility": "protected",

        "openingCurlyBraceOnSameLine": True

    }

    lineHeader = '==================='
    
    errors = []
    magicSetters = []
    magicGetters = []

    commands = {
        '@php': 'phpOpenTagCommand',
        '@endPhp': 'phpEndTagCommand',
        '@class': 'parseClassCommand',
        '@c': 'parseClassCommand',
        '@endClass': 'endOfClassCommand',
        '@ec': 'endOfClassCommand',
        '@endInterface': 'endOfClassCommand',
        '@ei': 'endOfClassCommand',
        '@const': 'parseConstantCommand',
        '@property': 'parsePropertyCommand',
        '@p': 'parsePropertyCommand',
        '@method': 'parseMethodCommand',
        '@m': 'parseMethodCommand',
        '@function': 'parseFunctionCommand',
        '@f': 'parseFunctionCommand',
        '@interface': 'parseInterfaceCommand',
        '@i': 'parseInterfaceCommand'
    }

    classOptions = {
        'className': '',
        'generateConstructer': False,
        'generateDestructer': False,
        'isAbstract': False,
        'hasInterface': False
    }

    invalidTypeHints = ['int', 'string', 'bool', 'boolean', 'trait', 'traits', 'float']

    isInterfaceMode = False

    def run(self, edit):

        #print sublime.Settings.has('test')
        #print sublime.Settings.has('test')

        self.isInterfaceMode = False
        self.errors = []
        self.magicSetters = []
        self.magicGetters = []
        self.settings = self.readSettings()

        # print self.settings['numberOfSpaces']

        regionsToModify = []
        regions = self.view.split_by_newlines(sublime.Region(0, self.view.size()))

        #print regions

        for region in regions:

            lineStr = self.view.substr(region)

            match = re.match(r'^([\s])*@.*', lineStr)
            if match:

                newLineStr = self.parse(lineStr)
                #print newLineStr
                #print len(newLineStr)

                if(len(newLineStr) > 0):

                    tabOffset = 0
                    numOfTabs = 0

                    if(self.view.settings().get('translate_tabs_to_spaces')):
                        numOfTabs = newLineStr.count('\t')
                        tabOffset = self.view.settings().get('tab_size') * numOfTabs
                    
                    #print newLineStr.count('\t')
                    #print tabOffset

                    regionsToModify.append({'region': region, 'replacementStr': newLineStr, 'count': len(newLineStr), 'tabOffset': tabOffset, 'numOfTabs': numOfTabs})

        #print regionsToModify

        offset = 0
        shouldAddToRegion = False

        for regionDict in regionsToModify:

            #print regionDict

            #offset += regionDict['tabOffset']
            #print offset

            #print 'offset: '+str(offset)

            #print regionDict['count']

            originalCharCount = regionDict['region'].end() - regionDict['region'].begin()

            #print originalCharCount

            if shouldAddToRegion:

                modifiedRegion = sublime.Region(regionDict['region'].begin() + offset, regionDict['region'].end() + offset)
                
                #print modifiedRegion

                #charCountForRegion = (regionDict['region'].end() + offset) + (regionDict['region'].begin() + offset)
                self.view.replace(edit, modifiedRegion, regionDict['replacementStr'])

            else:
                
                modifiedRegion = sublime.Region(regionDict['region'].begin() - offset, regionDict['region'].end() - offset)
                #print modifiedRegion

                #charCountForRegion = (regionDict['region'].end() - offset) - (regionDict['region'].begin() - offset)
                self.view.replace(edit, modifiedRegion, regionDict['replacementStr'])
                

            if(originalCharCount > regionDict['count']):
                offset = originalCharCount - regionDict['count'] - (offset + regionDict['tabOffset'] - regionDict['numOfTabs'])
                shouldAddToRegion = False
                #print 'shouldNotAdd'
            else:
                offset = regionDict['count'] + (offset + regionDict['tabOffset'] - regionDict['numOfTabs']) - originalCharCount
                shouldAddToRegion = True
                #print 'shouldAdd'

            #print offset

            #print 'here:'
            #print originalCharCount

        self.logErrors(self.errors)
    
    def logErrors(self, errors):

        if 'debugMode' in self.settings and self.settings['debugMode'] == True:

            if(len(errors) > 0):

                print('Error(s)', self.lineHeader)

                count = 1
                for error in errors:
                    print(str(count),': ',error)
                    count+=1

    def readSettings(self):

        defaultSettingsFile = sublime.packages_path()+'/PhpCodeGen/phpcodegen.sublime-settings'
        userSettingsFile = sublime.packages_path()+'/User/phpcodegen.sublime-settings'

        defaultSettings = {}
        userSettings = {}

        try:
            # open json config file and parse it as json
            f = open(defaultSettingsFile, 'r')
            defaultSettingsData = f.read()
            defaultSettings = self.parseJSON(defaultSettingsData)
            f.close()
        except:
            defaultSettings = {}
            print('Error occurred while reading or parsing the default settings file: ',defaultSettingsFile)

        try:
            # open json config file and parse it as json
            f = open(userSettingsFile, 'r')
            userSettingsData = f.read()
            userSettings = self.parseJSON(userSettingsData)
            f.close()
        except:
            userSettingsData = {}
            print('Error occurred while reading or parsing the user settings file: ',userSettingsFile)

        # merge them all together
        #tmpSettings = dict(self.settings.items() + defaultSettings.items())
        #tmpSettings = dict(tmpSettings.items() + userSettings.items())

        tmpSettings = dict(self.settings.items())
        tmpSettings.update(dict(defaultSettings.items()))
        tmpSettings.update(dict(userSettings.items()))

        #tmpSettings = list(self.settings.items()) + list(defaultSettings.items())
        #tmpSettings = list(tmpSettings.items()) + list(userSettings.items())

        # print(tmpSettings)

        # new_dict = list({'a':1, 'b':2}.items()) + list({'x':98, 'y':99}.items())

        return  tmpSettings


    def parseJSON(self, jsonStr):

        # remove all comments in the file, but not if preceeded by http:
        data = re.sub('\/\/.*\n', '', jsonStr)
        # remove all tabs and newlines from string
        data = re.sub('\t|\n', '', data)

        settings = json.loads(data)
        return settings

    def parse(self, str):

        genStr = ''

        # split the commands by new line
        commands = str.split('\n')

        if(len(commands) < 1):
            self.errors.append('Error! No valid commands were given! \n'+str)
            #self.degbugLog('Error! No valid commands were given! '+str)

        # iterator over all of the commands
        for command in commands:

            if(command == ''):
                continue

            self.degbugLog('Parsing command: '+command)

            pattern = re.compile('^(@\w+)(.*)')
            match = pattern.search(command)

            if(match):
                
                commandType = match.group(1);
                if(commandType in self.commands):
                    methodName = self.commands[commandType]
                    if (match.group(2)):
                        genStr += getattr(self, methodName)(match.group(2))
                    else:
                        genStr += getattr(self, methodName)()
                else:
                    self.errors.append('Unknown command given: "'+commandType+'"')

        return genStr


    def phpOpenTagCommand(self):

        return '<?php\n'

    def phpEndTagCommand(self):

        return '\n?>'

    def getTags(self, commandList):

        tags = []

        if('-tag' in commandList):
            index = commandList.index('-tag') + 1
            tagkey = commandList[index]
            if tagkey in self.settings['docblockTagGroup']:
                tags = self.settings['docblockTagGroup'][tagkey]

        return tags

    def getTagDocblocksAsStr(self, tags, tabs = 0):
        
        genStr = ''

        for tag in tags:
            genStr += self.getTabString(tabs)+' * '+tag['tag']+' '+tag['value']+'\n'

        return genStr

    def getTabString(self, tabs = 0):

        tabStr = ''
        for i in range(0, tabs):
            tabStr += '\t'

        return tabStr

    # receives the command str without the @class directive
    def parseClassCommand(self, commandStr):

        strAbstract = ''
        strExtends = ''
        strInterface = ''

        commandList = commandStr.split()

        # if('-c' in commandList):
        #   self.classOptions['generateConstructer'] = True

        # if('-d' in commandList):
        #   self.classOptions['generateDestructer'] = True

        if('-a' in commandList):
            self.classOptions['isAbstract'] = True
            strAbstract = 'abstract '

        if('-e' in commandList):
            self.classOptions['extendsClass'] = True
            index = commandList.index('-e') + 1
            self.classOptions['extendedClass'] = commandList[index]
            strExtends = ' extends '+self.classOptions['extendedClass']+' '

        if('-i' in commandList):
            self.classOptions['hasInterface'] = True
            index = commandList.index('-i') + 1
            interfaceList = commandList[index].split(',')
            strInterfaceList = ',       '.join(interfaceList)+' '
            strInterface+= ' implements '+strInterfaceList

        tags = self.getTags(commandList)

        self.classOptions['className'] = commandList[-1]
        openingCurlyBrace = self.getOpeningCurlyBrace()
    
        str = self.genDockBlockForClass(self.classOptions['className'], tags)
        str += strAbstract+'class '+self.classOptions['className']+strExtends+strInterface+' '+openingCurlyBrace
        str += self.getNewLinesAsString(self.settings['newLinesAfterClassDeclaration'])
        str = self.replaceExtraSpacesWithSingleSpace(2, str)

        return str

    def parseInterfaceCommand(self, commandStr):

        commandList = commandStr.split()
        strInterface = ''

        if('-e' in commandList):
            self.classOptions['hasInterface'] = True
            index = commandList.index('-e') + 1
            interfaceList = commandList[index].split(',')
            strInterfaceList = ',       '.join(interfaceList)+' '
            strInterface+= ' extends '+strInterfaceList 

        tags = self.getTags(commandList)

        interfaceName = commandList[-1]

        genStr = self.genDockBlockForClass(interfaceName, tags)
        genStr += 'interface '+interfaceName+strInterface+' {'
        genStr += self.getNewLinesAsString(self.settings['newLinesAfterClassDeclaration'])
        genStr = self.replaceExtraSpacesWithSingleSpace(2, genStr)

        self.isInterfaceMode = True

        return genStr

    def parseConstantCommand(self, commandStr):

        genStr = ''

        commandList = commandStr.split()

        tags = self.getTags(commandList)



        if('-q' in commandList and '-tag' not in commandList):
            
            name = commandList[1]
            value = commandList[2:]
            genStr += self.genDockBlockForConstant(name, tags)
            genStr += self.getNewLinesAsString(self.settings['numberOfSpaces'])+'\tconst '+name+' = \''+' '.join(value)+'\';'+self.getNewLinesAsString(self.settings['numberOfSpaces'])
        
        elif('-q' in commandList and '-tag' in commandList):

            name = commandList[3]
            value = commandList[4:]
            genStr += self.genDockBlockForConstant(name, tags)
            genStr += self.getNewLinesAsString(self.settings['numberOfSpaces'])+'\tconst '+name+' = \''+' '.join(value)+'\';'+self.getNewLinesAsString(self.settings['numberOfSpaces'])

        elif('-tag' in commandList and '-q' not in commandList):

            name = commandList[2]
            value = commandList[3]
            genStr += self.genDockBlockForConstant(name, tags)
            genStr += self.getNewLinesAsString(self.settings['numberOfSpaces'])+'\tconst '+name+' = '+value+';'+self.getNewLinesAsString(self.settings['numberOfSpaces'])

        else: 
            genStr += self.genDockBlockForConstant(commandList[0], tags)
            genStr += self.getNewLinesAsString(self.settings['numberOfSpaces'])+'\tconst '+commandList[0]+' = '+commandList[1]+';'+self.getNewLinesAsString(self.settings['numberOfSpaces'])

        return self.replaceExtraSpacesWithSingleSpace(2, genStr)

    def parsePropertyCommand(self, commandStr):

        commandList = commandStr.split()

        # default visibility for property
        visibility = self.settings['defaultPropertyVisibility']
        dataType = None
        propertyName = commandList[-1]

        tags = self.getTags(commandList)

        if('-v' in commandList):
            visibilityIndex = commandList.index('-v') + 1
            visibility = commandList[visibilityIndex]
            if not self.validVisibiltyForProperty(visibility):
                self.errors.append('Visibility specificed is not valid: "'+visibility+'" for property: "'+propertyName+'"')
                visibility = 'protected'
        
        if('-t' in commandList):
            typeIndex = commandList.index('-t') + 1
            dataType = commandList[typeIndex]

        static = ''

        isStatic = False

        if('-s' in commandList):
            static = ' static'
            isStatic = True

        genStr = self.genDockBlockForProperty(propertyName, dataType, tags = tags)+self.getNewLinesAsString(self.settings['numberOfSpaces'])+'\t'+visibility+static+' $'+propertyName+';'+self.getNewLinesAsString(self.settings['numberOfSpaces'])

        if('-set' in commandList):
            genStr += self.generateSetter(propertyName, dataType = dataType, isStatic = isStatic)

        # if('-mset' in commandList):
        #   self.magicSetters.append(propertyName)

        if('-get' in commandList):
            genStr += self.generateGetter(propertyName, dataType = dataType, isStatic = isStatic)

        # if('-mget' in commandList):
        #   self.magicGetters.append(propertyName)


        #print genStr

        return genStr

    def generateSetter(self, propertyName = None, dataType = None, isStatic = False):

        methodName = 'set'+self.upperCaseFirstLetterOnly(propertyName)
        visibility = 'public'
        dataTypeStr = '$value'

        if(dataType and dataType not in self.invalidTypeHints):
            dataTypeStr = dataType+' $value'

        params = [dataTypeStr]

        methodBody = '\t\t$this->'+propertyName+' = $value;'

        return self.generateStubMethod(methodName, visibility, isStatic, methodBody, params)

    def generateGetter(self, propertyName = None, dataType = None, isStatic = False):

        methodName = 'get'+self.upperCaseFirstLetterOnly(propertyName)
        visibility = 'public'
        returnType = '$this->'+propertyName

        if(dataType):
            returnType = dataType

        methodBody = '\t\treturn $this->'+propertyName+';'

        return self.generateStubMethod(methodName, visibility, isStatic, methodBody, returnType = returnType)

    def parseMethodCommand(self, commandStr):
        
        commandList = commandStr.split()
        visibility = self.settings['defaultMethodVisibility']
        methodName = commandList[-1]
        returnType = None
        abstract = False
        isFinal = False
        static = False

        tags = self.getTags(commandList)

        if('-s' in commandList):
            static = True

        if('-v' in commandList):
            visibilityIndex = commandList.index('-v') + 1
            visibility = commandList[visibilityIndex]
            if not self.validVisibiltyForProperty(visibility):
                self.errors.append('Visibility specificed is not valid: "'+visibility+'" for method: "'+methodName+'"')
                visibility = 'public'

        if('-r' in commandList):
            returnIndex = commandList.index('-r') + 1
            returnType = commandList[returnIndex]

        if('-a' in commandList):
            abstract = True

        if('-f' in commandList):
            isFinal = True

        # parse parameter
        params = self.getParametersFromString(commandStr)

        return self.generateStubMethod(methodName, visibility, static, params = params, returnType = returnType, isAbstract = abstract, isFinal = isFinal, tags = tags)

    def parseFunctionCommand(self, commandStr):
        
        commandList = commandStr.split()
        visibility = ''
        methodName = commandList[-1]
        returnType = None
        static = False

        if('-s' in commandList):
            static = True

        if('-r' in commandList):
            returnIndex = commandList.index('-r') + 1
            returnType = commandList[returnIndex]

        # parse parameter
        params = self.getParametersFromString(commandStr)

        tags = self.getTags(commandList)


        return self.generateStubMethod(methodName, visibility, static, params = params, returnType = returnType, tags = tags)


    def getParametersFromString(self, s):

        params = []
        result = re.match('.*-p \{(.*)\}', s)

        if(result):
            paramList = result.group(1).split(',')
            if(len(paramList) > 0):
                
                for param in paramList:

                    argList = param.strip().split(':')

                    if(len(argList) > 1):
                        params.append(argList[0]+' '+self.getVariable(argList[1]))
                    else:
                        params.append(self.getVariable(argList[0]))

            else:
                self.errors.append('No parameters passed: "'+s+'"')

        return params

    def getVariable(self, paramStr):
    
        paramValueList = paramStr.split('=')

        if(len(paramValueList) > 1):
            return self.addDollarSignToVariable(paramValueList[0])+' = '+paramValueList[1]
        else:
            return self.addDollarSignToVariable(paramValueList[0])

    def addDollarSignToVariable(self, strVar):

        if(not re.match('^\$', strVar)):
            return '$'+strVar

        return strVar

    def generateStubMethod(self, methodName = None, visibility = 'public', isStatic = False, methodBody = '', params = [], returnType = None, isAbstract = False, isFinal = False, tags = []):

        staticStr = ''
        if(isStatic):
            staticStr = ' static '

        abstractStr = ''
        if(isAbstract):
            abstractStr = ' abstract '

        finalStr = ''
        if(isFinal):
            finalStr = ' final '

        paramStr = ''

        openingCurlyBrace = self.getOpeningCurlyBrace(1)

        if(len(params) > 0):
            paramStr+= ', '.join(params)


        if self.isInterfaceMode:

            genStr = self.genDockBlockForMethod(methodName, returnType, params, tags = tags)
            genStr += '\tpublic function '+methodName+'('+paramStr+');'

        else:

            if(isAbstract):

                genStr = self.genDockBlockForMethod(methodName, returnType, params, tags = tags)

                modifiers = abstractStr+visibility+staticStr
                modifiers = re.sub(r'^ ', '', modifiers)

                if len(modifiers) == 0:
                    modifiers = ''
                else:
                    modifiers+= ' '


                genStr += '\t'+modifiers+'function '+methodName+'('+paramStr+');'

            else:

                modifiers = abstractStr+finalStr+visibility+staticStr
                modifiers = re.sub(r'^ ', '', modifiers)

                if len(modifiers) == 0:
                    modifiers = ''
                else:
                    modifiers+= ' '

                genStr = self.genDockBlockForMethod(methodName, returnType, params, tags = tags)
                genStr += '\t'+modifiers+'function '+methodName+'('+paramStr+')'+openingCurlyBrace
                genStr += self.getNewLinesAsString(self.settings['newLinesAfterMethodDeclaration'])
                genStr += methodBody
                genStr += self.getNewLinesAsString(self.settings['newLinesBeforeMethodClosingBrace'])
                genStr += '\t}'

        return self.replaceExtraSpacesWithSingleSpace(2, genStr)

    def validVisibiltyForProperty(self, visibilityStr):
    
        if(visibilityStr != 'public' and visibilityStr != 'protected' and visibilityStr != 'private'):
            return False
        return True

    def endOfClassCommand(self):

        genStr = ''
        genStr += self.genMagicGetters()
        genStr += self.genMagicSetters()
        genStr += self.getNewLinesAsString(self.settings['newLinesBeforeClassClosingBrace'])+'}'

        self.magicGetters = []
        self.magicSetters = []

        self.isInterfaceMode = False

        return genStr

    def genMagicGetters(self):

        if(len(self.magicGetters) < 1):
            return ''

        methodName = '__get'
        returnType = 'mixed'
        params = ['$strName']
        paramStr = ''.join(params)
        methodBody = '\n\t\tswitch($strName) {\n\n'

        for var in self.magicGetters:
            methodBody += '\t\t\tcase \''+var+'\':\n'
            methodBody += '\t\t\t\treturn $this->'+var+';\n\n'

        methodBody += '\n\t\t}\n'

        genStr = self.genDockBlockForMethod(methodName, returnType, params)
        genStr += '\tpublic function '+methodName+'('+paramStr+') {'
        genStr += self.getNewLinesAsString(self.settings['newLinesAfterMethodDeclaration'])
        genStr += methodBody
        genStr += self.getNewLinesAsString(self.settings['newLinesBeforeMethodClosingBrace'])
        genStr += '\t}'

        return genStr

    def genMagicSetters(self):
        
        if(len(self.magicSetters) < 1):
            return ''

        methodName = '__set'
        returnType = 'void'
        params = ['$strName', '$value']
        paramStr = ', '.join(params)
        methodBody = '\n\t\tswitch($strName) {\n\n'

        for var in self.magicSetters:
            methodBody += '\t\t\tcase \''+var+'\':\n'
            methodBody += '\t\t\t\t$this->'+var+' = $value;\n'
            methodBody += '\t\t\t\tbreak;\n\n'

        methodBody += '\n\t\t}\n'

        genStr = self.genDockBlockForMethod(methodName, returnType, params)
        genStr += '\tpublic function '+methodName+'('+paramStr+') {'
        genStr += self.getNewLinesAsString(self.settings['newLinesAfterMethodDeclaration'])
        genStr += methodBody
        genStr += self.getNewLinesAsString(self.settings['newLinesBeforeMethodClosingBrace'])
        genStr += '\t}'

        return genStr

    # Gets the new lines
    def getNewLinesAsString(self, count):
        genStr = ''
        for i in range(0, count):
            genStr+= '\n'
        return genStr

    def replaceExtraSpacesWithSingleSpace(self, spaces, s):

        return re.sub(' {'+str(spaces)+',}', ' ', s)

    def upperCaseFirstLetterOnly(self, s):
        return s[0].upper() + s[1:]

    def isDocBLockEnabled(self):

        if(self.settings['autoGenerateDockBlocks']):            
            return True

        return False

    # =============== DocBlock Generators ================

    def genDockBlockForClass(self, className, tags = []):

        if(self.isDocBLockEnabled()):

            genStr = self.getNewLinesAsString(self.settings['newLinesAboveClassDocBlock'])
            genStr += '/**\n'
            genStr += ' * '+className+'\n'      
            genStr += self.getTagDocblocksAsStr(tags)
            genStr += ' */\n'
            genStr += self.getNewLinesAsString(self.settings['newLinesBelowClassDocBlock'])

            return genStr

        return ''

    def genDockBlockForConstant(self, constName, tags = []):

        if(self.isDocBLockEnabled()):

            genStr = self.getNewLinesAsString(self.settings['newLinesAboveConstantDockBlock'])
            genStr += '\t/**\n'     
            genStr += '\t * '+constName+'\n'
            genStr += self.getTagDocblocksAsStr(tags, 1)
            genStr += '\t */\n'
            genStr += self.getNewLinesAsString(self.settings['newLinesBelowConstantDockBlock'])

            return genStr

        return ''

    def genDockBlockForProperty(self, propertyName, dataType = None, tags = []):

        if(self.isDocBLockEnabled()):

            typeStr = 'datatype'
            if(dataType):
                typeStr = dataType

            genStr = self.getNewLinesAsString(self.settings['newLinesAbovePropertyDockBlock'])
            genStr += '\t/**\n'     
            genStr += '\t * '+propertyName+'\n'
            genStr += '\t * @var '+typeStr+'\n'
            genStr += self.getTagDocblocksAsStr(tags, 1)
            genStr += '\t */\n'
            genStr += self.getNewLinesAsString(self.settings['newLinesBelowPropertyDockBlock'])

            return genStr

        return ''

    def genDockBlockForMethod(self, methodName, returnType = None, params = [], tags = []):

        #print params

        paramStr = ''

        if(len(params) > 0):

            for param in params:
                paramStr += '\t * @param '+param+'\n'

        if(self.isDocBLockEnabled()):

            returnTypeStr = 'void'
            if(returnType):
                returnTypeStr = returnType

            genStr = self.getNewLinesAsString(self.settings['newLinesAboveMethodDockBlock'])
            genStr += '\t/**\n'     
            genStr += '\t * '+methodName+'\n'
            genStr += self.getTagDocblocksAsStr(tags, 1)
            genStr += paramStr
            genStr += '\t * @return '+returnTypeStr+'\n'
            genStr += '\t */\n'
            genStr += self.getNewLinesAsString(self.settings['newLinesBelowMethodDockBlock'])

            return genStr

        return ''

    def getOpeningCurlyBrace(self, tabs = 0):

        if self.settings['openingCurlyBraceOnSameLine']:
            return' {'
        else :
            return '\n'+self.getTabString(tabs)+'{'

    # ============== Internal Debug Methods =================

    def degbugLog(self, str):
        if(self.settings['debugMode']):
            print(str)